
//__________________________________________________________________________________
//__________________________________________________________________________________
//
//							MISCELLANEOUS FUNCTIONS
//__________________________________________________________________________________
//__________________________________________________________________________________


//JOINABLE NPCS ARRAY MACRO__________________________________________________________
//
DEFINE_ACTION_MACRO JOINABLE_NPC_ARRAYS BEGIN
	//PDIALOG.2DA exists in all games
	ACTION_DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~PDIALOG~ => ~~ END
	//Check PDIALOG.2DA file variants referenced in CAMPAIGN.2DA
	ACTION_IF FILE_EXISTS_IN_GAME ~CAMPAIGN.2DA~ BEGIN
		COPY_EXISTING ~CAMPAIGN.2DA~ ~CAMPAIGN.2DA~
			COUNT_2DA_ROWS 32 "cntrow"
			FOR (i = 0; i < cntrow; i = i + 1) BEGIN
				READ_2DA_ENTRY i 11 32 file
				TO_UPPER file
				DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~%file%~ => ~~ END
			END
		BUT_ONLY
	END
	//Generate array with joinable NPC DV
	ACTION_PHP_EACH JOINABLE_NPC_ARRAY_2da AS file => ~~ BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME ~%file%.2da~ BEGIN
			COPY_EXISTING ~%file%.2da~ ~override~
				COUNT_2DA_ROWS 3 "cntrow"
				FOR (i = 1; i < cntrow; i = i + 1) BEGIN
					READ_2DA_ENTRY i 0 3 "dv"
					TO_UPPER dv
					DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_dv BEGIN ~%dv%~ => ~~ END
				END
			BUT_ONLY
		END
	END
	//Generate array with joinable NPC cre files
	COPY_EXISTING_REGEXP GLOB ~.+\.CRE~ ~override~
		READ_ASCII DEATHVAR "dv" (32) NULL
		TO_UPPER dv
		PATCH_IF VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%dv%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%dv%~ END
		END
		PATCH_IF NOT VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%dv%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY NON_JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%dv%~ END
		END
	BUT_ONLY
END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION multiclass_text BEGIN

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5__multi_text.d5~) BEGIN
  ACTION_IF (FILE_EXISTS_IN_GAME ~clastext.2da~) BEGIN
  	COPY_EXISTING ~clastext.2da~ ~override~
		COUNT_2DA_COLS cols
		READ_2DA_ENTRIES_NOW rows cols  
		FOR (row = 1; row < rows; ++row) BEGIN
		  READ_2DA_ENTRY_FORMER rows row 0 ~text~
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC~ BEGIN
		    SET c_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_CLERIC~ BEGIN
		    SET fc_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_MAGE~ BEGIN
		    SET cm_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_THIEF~ BEGIN
		    SET ct_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_RANGER~ BEGIN
		    SET cr_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_DRUID~ BEGIN
		    SET fd_row = %row%
		  END
		END
		SET_2DA_ENTRY %c_row% 3 cols RESOLVE_STR_REF (@10001)
		SET_2DA_ENTRY %c_row% 5 cols RESOLVE_STR_REF (@10002)
		SET_2DA_ENTRY %c_row% 4 cols RESOLVE_STR_REF (@10005)
		SET_2DA_ENTRY %fc_row% 3 cols RESOLVE_STR_REF (@10011)
		SET_2DA_ENTRY %fc_row% 5 cols RESOLVE_STR_REF (@10012)
		SET_2DA_ENTRY %fc_row% 4 cols RESOLVE_STR_REF (@10015)
		SET_2DA_ENTRY %cm_row% 3 cols RESOLVE_STR_REF (@10021)
		SET_2DA_ENTRY %cm_row% 5 cols RESOLVE_STR_REF (@10022)
		SET_2DA_ENTRY %cm_row% 4 cols RESOLVE_STR_REF (@10025)
		SET_2DA_ENTRY %ct_row% 3 cols RESOLVE_STR_REF (@10031)
		SET_2DA_ENTRY %ct_row% 5 cols RESOLVE_STR_REF (@10032)
		SET_2DA_ENTRY %ct_row% 4 cols RESOLVE_STR_REF (@10035)
		SET_2DA_ENTRY %cr_row% 3 cols RESOLVE_STR_REF (@10041)
		SET_2DA_ENTRY %cr_row% 5 cols RESOLVE_STR_REF (@10042)
		SET_2DA_ENTRY %cr_row% 4 cols RESOLVE_STR_REF (@10045)
		SET_2DA_ENTRY %fd_row% 3 cols RESOLVE_STR_REF (@10051)
		SET_2DA_ENTRY %fd_row% 5 cols RESOLVE_STR_REF (@10052)
		SET_2DA_ENTRY %fd_row% 4 cols RESOLVE_STR_REF (@10055)
  	BUT_ONLY
END
ACTION_IF (FILE_EXISTS_IN_GAME ~sodcltxt.2da~) BEGIN
  	COPY_EXISTING ~sodcltxt.2da~ ~override~
		COUNT_2DA_COLS cols
		READ_2DA_ENTRIES_NOW rows cols
		FOR (row = 1; row < rows; ++row) BEGIN
		  READ_2DA_ENTRY_FORMER rows row 0 ~text~
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC~ BEGIN
		    SET c_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_CLERIC~ BEGIN
		    SET fc_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_MAGE~ BEGIN
		    SET cm_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_THIEF~ BEGIN
		    SET ct_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_RANGER~ BEGIN
		    SET cr_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_DRUID~ BEGIN
		    SET fd_row = %row%
		  END
		END
		SET_2DA_ENTRY %c_row% 3 cols RESOLVE_STR_REF (@10001)
		SET_2DA_ENTRY %c_row% 5 cols RESOLVE_STR_REF (@10002)
		SET_2DA_ENTRY %c_row% 4 cols RESOLVE_STR_REF (@10005)
		SET_2DA_ENTRY %fc_row% 3 cols RESOLVE_STR_REF (@10011)
		SET_2DA_ENTRY %fc_row% 5 cols RESOLVE_STR_REF (@10012)
		SET_2DA_ENTRY %fc_row% 4 cols RESOLVE_STR_REF (@10015)
		SET_2DA_ENTRY %cm_row% 3 cols RESOLVE_STR_REF (@10021)
		SET_2DA_ENTRY %cm_row% 5 cols RESOLVE_STR_REF (@10022)
		SET_2DA_ENTRY %cm_row% 4 cols RESOLVE_STR_REF (@10025)
		SET_2DA_ENTRY %ct_row% 3 cols RESOLVE_STR_REF (@10031)
		SET_2DA_ENTRY %ct_row% 5 cols RESOLVE_STR_REF (@10032)
		SET_2DA_ENTRY %ct_row% 4 cols RESOLVE_STR_REF (@10035)
		SET_2DA_ENTRY %cr_row% 3 cols RESOLVE_STR_REF (@10041)
		SET_2DA_ENTRY %cr_row% 5 cols RESOLVE_STR_REF (@10042)
		SET_2DA_ENTRY %cr_row% 4 cols RESOLVE_STR_REF (@10045)
		SET_2DA_ENTRY %fd_row% 3 cols RESOLVE_STR_REF (@10051)
		SET_2DA_ENTRY %fd_row% 5 cols RESOLVE_STR_REF (@10052)
		SET_2DA_ENTRY %fd_row% 4 cols RESOLVE_STR_REF (@10055)
  	BUT_ONLY
  END
  COPY ~faiths_and_powers/lib/markers/d5_marker.d5~ ~override/d5__multi_text.d5~
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION druid_class_text BEGIN

ACTION_IF (FILE_EXISTS_IN_GAME ~clastext.2da~) BEGIN
  COPY_EXISTING ~clastext.2da~ ~override~
	COUNT_2DA_COLS cols 
	READ_2DA_ENTRIES_NOW rows cols 
	FOR (row = 1; row < rows; ++row) BEGIN 
	  READ_2DA_ENTRY_FORMER rows row 0 ~text~ 
	  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~DRUID~ BEGIN
	    SET patch_row = %row%
	  END
	END
	SET_2DA_ENTRY %patch_row% 3 cols RESOLVE_STR_REF (@70001)
	SET_2DA_ENTRY %patch_row% 5 cols RESOLVE_STR_REF (@70002)
	SET_2DA_ENTRY %patch_row% 4 cols RESOLVE_STR_REF (@70003)
  BUT_ONLY
END
ACTION_IF (FILE_EXISTS_IN_GAME ~sodcltxt.2da~) BEGIN
  COPY_EXISTING ~sodcltxt.2da~ ~override~
	COUNT_2DA_COLS cols 
	READ_2DA_ENTRIES_NOW rows cols 
	FOR (row = 1; row < rows; ++row) BEGIN 
	  READ_2DA_ENTRY_FORMER rows row 0 ~text~ 
	  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~DRUID~ BEGIN
	    SET patch_row = %row%
	  END
	END
	SET_2DA_ENTRY %patch_row% 3 cols RESOLVE_STR_REF (@70001)
	SET_2DA_ENTRY %patch_row% 5 cols RESOLVE_STR_REF (@70002)
	SET_2DA_ENTRY %patch_row% 4 cols RESOLVE_STR_REF (@70003)
  BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION druid_xp BEGIN

// from BG2Tweaks

COPY_EXISTING ~xplevel.2da~ ~override~
REPLACE_TEXTUALLY
~CLERIC \(.*\)
DRUID \(.*\)~
~CLERIC \1
DRUID  \1~
BUT_ONLY

ACTION_IF FILE_EXISTS_IN_GAME ~lunumab.2da~ THEN BEGIN
  COPY_EXISTING ~lunumab.2da~ ~override~
    READ_2DA_ENTRY  2 1 5 "cleric"   // read trueclass cleric value for initial HLA level
    SET_2DA_ENTRY   6 1 5 "%cleric%" // write trueclass cleric value for initial HLA level into druid slot
    READ_2DA_ENTRY  9 1 5 "f_c"      // read dual f/c value for initial HLA level
    SET_2DA_ENTRY  15 1 5 "%f_c%"    // write dual f/c cleric value for initial HLA level into dual f/d slot
    READ_2DA_ENTRY 22 1 5 "multic"   // read multiclass cleric value for initial HLA level
    SET_2DA_ENTRY  24 1 5 "%multic%" // write multiclass cleric value for initial HLA level into multiclass druid slot
  BUT_ONLY
END

COPY_EXISTING ~mxsplprs.2da~ ~override/mxspldru.2da~

END // end function

//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION clear_druid_clab BEGIN

  ACTION_IF !(FILE_EXISTS_IN_GAME ~d5__no_shapeshift.d5~) BEGIN
	COPY_EXISTING ~clabdr01.2da~ ~override~
	  REMOVE_2DA_ROW 1 39
	  REMOVE_2DA_ROW 1 39
	  REMOVE_2DA_ROW 1 39
	IF_EXISTS BUT_ONLY
	COPY ~faiths_and_powers/lib/markers/d5_marker.d5~ ~override/d5__no_shapeshift.d5~
  END
  
END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION enable_more_paladins BEGIN

ACTION_IF (%champion_tyr% + %champion_azuth% + %champion_moradin% + %champion_kelemvor% + %champion_tempus% + %champion_bane% + %champion_helm% + %champion_talos% + %champion_red% > 0) BEGIN
//any race can have their pallys
  COPY_EXISTING ~clsrcreq.2da~ ~override~
	COUNT_2DA_ROWS 8 rows
	FOR (row = 0 ; row < rows ; ++row) BEGIN
      READ_2DA_ENTRY row 0 8 entry
      PATCH_IF (~%entry%~ STRING_EQUAL_CASE ~PALADIN~) OR (~%entry%~ STRING_EQUAL_CASE ~BLACKGUARD~) BEGIN // paladin/blackguard
    	SET_2DA_ENTRY  row 2 8 1
    	SET_2DA_ENTRY  row 3 8 1
    	SET_2DA_ENTRY  row 4 8 1
    	SET_2DA_ENTRY  row 5 8 1
    	SET_2DA_ENTRY  row 6 8 1
    	SET_2DA_ENTRY  row 7 8 1
      END
	END
	PRETTY_PRINT_2DA
  IF_EXISTS BUT_ONLY
//Dwarves need to be able to take the champion class.  Cha 13 requirement
  COPY_EXISTING ~ABCLASRQ.2da~ ~override~
    SET_2DA_ENTRY 6 6 6 13
    SET_2DA_ENTRY 30 6 6 13
    SET_2DA_ENTRY 31 6 6 13
    SET_2DA_ENTRY 32 6 6 13
  BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION paladin_spell_tables BEGIN

  COPY ~faiths_and_powers/kits/champions/mxsplpal.2da~ ~override~

END // end function


DEFINE_ACTION_FUNCTION ranger_spell_tables BEGIN

  COPY ~faiths_and_powers/kits/rangers/mxsplran.2da~ ~override~

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION more_ranger_alignments BEGIN

ACTION_PHP_EACH d5_fnp_kit_class_access AS kit => class BEGIN
  ACTION_IF (~%class%~ STRING_EQUAL_CASE ~SCOUT~) BEGIN
	COPY_EXISTING ~kitlist.2da~ ~override~
//	  COUNT_2DA_COLS cols
	  READ_2DA_ENTRIES_NOW rows 9
	  FOR (row = 7; row < rows; ++row) BEGIN
		READ_2DA_ENTRY_FORMER rows row 5 ~clab~
		PATCH_IF ~%clab%~ STRING_EQUAL_CASE ~%kit%~ BEGIN
		  SET kit_index = %row%
		  READ_2DA_ENTRY_FORMER rows kit_index 1 kit_label
		END
	  END
	BUT_ONLY
	APPEND ~fallen.2da~ ~%kit_label%%TAB%0~
	COPY_EXISTING ~alignmnt.2da~ ~override~
	  COUNT_2DA_COLS num_cols
	  READ_2DA_ENTRIES_NOW ~r2en_align~ num_cols
	  FOR (row = 3; row < r2en_align; row += 1) BEGIN
		READ_2DA_ENTRY_FORMER ~r2en_align~ row 0 align_name
		PATCH_IF (~%align_name%~ STRING_EQUAL_CASE ~%kit_label%~) BEGIN
		  FOR (col = 1; col < num_cols; col += 1) BEGIN
			SET_2DA_ENTRY_LATER ~s2el_align~ row col 1 
		  END
		END
	  END
	  SET_2DA_ENTRIES_NOW ~s2el_align~ num_cols
	BUT_ONLY
  END
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION enable_multiclasses BEGIN

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5__more_multi.d5~) BEGIN
 ACTION_IF FILE_EXISTS_IN_GAME ~CLSRCREQ.2da~ BEGIN
  COPY_EXISTING ~clsrcreq.2da~ ~override~
	COUNT_2DA_ROWS 8 rows
	FOR (row = 0 ; row < rows ; ++row) BEGIN
      READ_2DA_ENTRY row 0 8 entry
      PATCH_IF (("%entry%" STRING_COMPARE_CASE "FIGHTER_CLERIC"      = 0) OR
              ("%entry%" STRING_COMPARE_CASE "CLERIC_THIEF"        = 0)) BEGIN // cleric/thief, fighter/cleric
    	SET_2DA_ENTRY  row 1 8 1
    	SET_2DA_ENTRY  row 2 8 1
    	SET_2DA_ENTRY  row 3 8 1
    	SET_2DA_ENTRY  row 4 8 1
    	SET_2DA_ENTRY  row 5 8 1
    	SET_2DA_ENTRY  row 6 8 1
    	SET_2DA_ENTRY  row 7 8 1
      END
      PATCH_IF ("%entry%" STRING_COMPARE_CASE "CLERIC_MAGE"         = 0) BEGIN // cleric/mage
    	SET_2DA_ENTRY  row 1 8 1
    	SET_2DA_ENTRY  row 2 8 1
    	SET_2DA_ENTRY  row 3 8 1
    	SET_2DA_ENTRY  row 6 8 1
      END
      PATCH_IF ("%entry%" STRING_COMPARE_CASE "CLERIC_RANGER"       = 0) BEGIN // cleric/ranger
    	SET_2DA_ENTRY  row 1 8 1
    	SET_2DA_ENTRY  row 2 8 1
    	SET_2DA_ENTRY  row 3 8 1
    	SET_2DA_ENTRY  row 5 8 1
      END
      PATCH_IF (("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE"        = 0) OR
              ("%entry%" STRING_COMPARE_CASE "FIGHTER_THIEF"       = 0) OR
              ("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE_THIEF"  = 0) OR
              ("%entry%" STRING_COMPARE_CASE "MAGE_THIEF"          = 0)) BEGIN // other human multiclasses
    	SET_2DA_ENTRY  row 1 8 1
      END
/*
      PATCH_IF (("%entry%" STRING_COMPARE_CASE "DRUID"               = 0) OR
    		  ("%entry%" STRING_COMPARE_CASE "FIGHTER_DRUID"       = 0)) BEGIN // druids and mystics
    	SET_2DA_ENTRY  row 1 8 1
    	SET_2DA_ENTRY  row 2 8 1
    	SET_2DA_ENTRY  row 3 8 1
    	SET_2DA_ENTRY  row 4 8 1
    	SET_2DA_ENTRY  row 5 8 1
    	SET_2DA_ENTRY  row 6 8 1
    	SET_2DA_ENTRY  row 7 8 1
      END
*/
      PATCH_IF ("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE_CLERIC" = 0) BEGIN // fighter/mage/cleric
    	SET_2DA_ENTRY  row 1 8 0
    	SET_2DA_ENTRY  row 2 8 0
    	SET_2DA_ENTRY  row 3 8 0
    	SET_2DA_ENTRY  row 4 8 0
    	SET_2DA_ENTRY  row 5 8 0
    	SET_2DA_ENTRY  row 6 8 0
    	SET_2DA_ENTRY  row 7 8 0
      END
	END
	PRETTY_PRINT_2DA
  BUT_ONLY
 END
 COPY ~faiths_and_powers/lib/markers/d5_marker.d5~ ~override/d5__more_multi.d5~
END

END // end function

/*
COPY K_race_class.2da files
  - count rows
  - if trueclass is not the only one
  - then delete trueclass row
*/

//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION remove_sc_menu_kits STR_VAR class = ~C~ BEGIN

  ACTION_FOR_EACH race IN ~D~ ~E~ ~G~ ~H~ ~HE~ ~HL~ ~HO~ BEGIN
	ACTION_IF FILE_EXISTS_IN_GAME ~K_%class%_%race%.2da~ BEGIN
	  COPY_EXISTING ~K_%class%_%race%.2da~ ~override~
		COUNT_2DA_COLS cols
		COUNT_2DA_ROWS cols rows
		PATCH_IF (rows > 3) BEGIN
		  READ_2DA_ENTRIES_NOW rows cols
		  SET rows_removed = 0
		  FOR (row = 1; row < rows; ++row) BEGIN
			READ_2DA_ENTRY_FORMER rows row 1 kit
			PATCH_IF 
					(%kit% = 0) OR 
		  			(%kit% = 17) OR 
		  			(%kit% = 19) OR 
		  			(%kit% = 20) OR 
		  			(%kit% = 21) OR 
		  			(%kit% = 4) OR 
		  			(%kit% = 5) OR 
		  			(%kit% = 6) BEGIN
			  REMOVE_2DA_ROW (row - rows_removed) cols
			  SET rows_removed += 1
			END
		  END
		END
	  BUT_ONLY
	END
  END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION remove_mc_menu_kits BEGIN

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5__remove_multi_menu.d5~) BEGIN
 ACTION_FOR_EACH class IN ~FD~ ~FC~ ~CR~ ~CT~ ~CM~ BEGIN
  ACTION_FOR_EACH race IN ~D~ ~E~ ~G~ ~H~ ~HE~ ~HL~ ~HO~ BEGIN
	ACTION_IF FILE_EXISTS_IN_GAME ~K_%class%_%race%.2da~ BEGIN
	  COPY_EXISTING ~K_%class%_%race%.2da~ ~override~
		COUNT_2DA_COLS cols
		COUNT_2DA_ROWS cols rows
		PATCH_IF (rows > 3) BEGIN
		  READ_2DA_ENTRIES_NOW rows cols
		  SET rows_removed = 0
		  FOR (row = 1; row < rows; ++row) BEGIN
			READ_2DA_ENTRY_FORMER rows row 1 kit
			PATCH_IF (%kit% = 0) BEGIN
			  REMOVE_2DA_ROW (row - rows_removed) cols
			  SET rows_removed += 1
			  INNER_ACTION BEGIN
				COPY ~faiths_and_powers/lib/markers/d5_marker.d5~ ~override/d5__remove_multi_menu.d5~
			  END
			END
		  END
		END
	  BUT_ONLY
	END
  END
 END
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION disable_dual_classing BEGIN

LAM d5_dual_classing

ACTION_IF (%d5_dual_class% = 0) BEGIN
  COPY_EXISTING ~dualclas.2da~ ~override~
	COUNT_2DA_COLS cols
	COUNT_2DA_ROWS cols rows
	FOR (row = 0; row < (rows - 1); ++row) BEGIN
	  SET_2DA_ENTRY row 2 cols 0
	  SET_2DA_ENTRY row 6 cols 0
	END
	PRETTY_PRINT_2DA
  BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION rename_holy_symbols STR_VAR item_name = ~~ BEGIN
  COPY_EXISTING ~belt12.itm~ ~override~
    READ_ASCII 0x3a lath_icon
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~belt13.itm~ ~override~
    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~belt14.itm~ ~override~
    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~ohtempus.itm~ ~override~
    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~beltty.itm~ ~override~
    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~beltbw.itm~ ~override~
    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
  COPY_EXISTING ~beltsh.itm~ ~override~
//    WRITE_ASCIIE 0x3a ~%lath_icon%~ #8
    SAY NAME2 ~%item_name%~
  IF_EXISTS BUT_ONLY
END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION shaman_spells BEGIN

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5_shmkn.2da~) BEGIN
  COPY_EXISTING ~splshmkn.2da~ ~override/d5_shmkn.2da~
END

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5shlist.2da~) BEGIN
<<<<<<<<  d5/d5shlist.2da
2DA      V1.0
0
				SHAMAN
>>>>>>>>
 COPY ~d5/d5shlist.2da~ ~override/d5shlist.2da~

 COPY_EXISTING_REGEXP GLOB ~^SPPR[1-7]\(0[1-9]\|[1-4][0-9]\|50\)\.spl$~ ~override~
  READ_SHORT 0x1c spell_type
  READ_BYTE 0x21 ok_druid
  PATCH_IF (spell_type = 2) && ((%ok_druid% BOR 0b01111111) = 0b01111111) BEGIN
	LPF NAME_NUM_OF_SPELL_RES STR_VAR spell_res = EVAL ~%SOURCE_RES%~ RET spell_name END
	PATCH_IF (FILE_CONTAINS_EVALUATED (~spell.ids~ ~%spell_name%~)) && !(FILE_CONTAINS_EVALUATED (~hidespl.2da~ ~%SOURCE_RES%~)) BEGIN
	  INNER_ACTION BEGIN
		APPEND ~d5shlist.2da~ ~%SOURCE_RES%	1~
	  END
	END
  END
 BUT_ONLY

// INCLUDE ~faiths_and_powers/lib/sequencer_menu_d5.tpa~
 INCLUDE ~faiths_and_powers/lib/sequencer_menu.tpa~

 LAF CREATE_SEQUENCER_MENU 
  INT_VAR 
	name = RESOLVE_STR_REF (~Spell Selection~)
	tip = RESOLVE_STR_REF (~Spell Selection~)
	desc = RESOLVE_STR_REF (~This ability allows you to learn new spells~)
	class = 2
	maxlevel = 7
	column = 1
  STR_VAR 
	spelltable = ~d5_shmkn~
	spelllist = ~d5shlist~
	resref = ~d5msham~
	icon = ~spcl919b~
	title = ~Spell Selection~
	label = ~Select a spell to learn~
	subspell = ~H~
 END
END

//learn spell item___________________________________________________________________
//
ACTION_IF !(FILE_EXISTS_IN_GAME ~d5shmsp.itm~) BEGIN
 COPY ~faiths_and_powers/kits/multiclass/499_shambarb/d5shmsp.itm~ ~override~			//	learn spells .itm
  SAY NAME1 @49911
  SAY NAME2 @49911
  SAY UNIDENTIFIED_DESC @49912
  SAY IDENTIFIED_DESC @49912
  LPF ALTER_ITEM_HEADER INT_VAR target = 7 speed = 0 STR_VAR icon = ~spcl919b~ END
  LPF ALTER_EFFECT INT_VAR match_opcode = 146 STR_VAR resource = ~d5msham~ END
END
CREATE EFF ~d5shmsp~
  WRITE_LONG 0x10 143
  WRITE_LONG 0x14 1
  WRITE_LONG 0x1c 14
  WRITE_LONG 0x24 9
  WRITE_SHORT 0x2c 100
  WRITE_EVALUATED_ASCII 0x30 ~D5SHMSP~ #8

ACTION_IF !(FILE_EXISTS_IN_GAME ~d5shmv1.spl~) BEGIN
 COPY ~faiths_and_powers/data/misc/d5_base.spl~ ~override/d5shmv1.spl~
  SAY NAME1 @49950
  SAY UNIDENTIFIED_DESC @49950
  WRITE_SHORT 0x1c 4
  LPF ALTER_SPELL_HEADER INT_VAR location = 4 target = 5 STR_VAR icon = ~spcl919b~ END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 1 parameter1 = 21 parameter2 = 5 timing = 9 STR_VAR resource = ~d5shmsp~ END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 172 target = 1 timing = 9 STR_VAR resource = ~d5shmv1~ END
END
ACTION_IF (FILE_EXISTS_IN_GAME ~d5shmv1.spl~) BEGIN
  COPY_EXISTING ~d5shmv1.spl~ ~override~
	LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 1 parameter1 = 21 parameter2 = 5 timing = 9 STR_VAR resource = ~d5shmsp~ END
END

ACTION_IF (FILE_EXISTS_IN_GAME ~clabsh01.2da~) BEGIN
  APPEND ~clabsh01.2da~ ~SPL_REST     GA_D5SPM3M  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** 
SHAMAN_LRN   GA_D5SHMV1  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
END
ACTION_IF (FILE_EXISTS_IN_GAME ~clabshgs.2da~) BEGIN
  APPEND ~clabshgs.2da~ ~SPL_REST     GA_D5SPM3M  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** 
SHAMAN_LRN   GA_D5SHMV1  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
END

COPY_EXISTING ~kitlist.2da~ ~override~
  COUNT_2DA_ROWS 9 rows
  FOR (row = 30 ; row < rows ; row = row + 1 ) BEGIN
	READ_2DA_ENTRY row 5 9 kitclab
	READ_2DA_ENTRY row 8 9 kitclass
	PATCH_IF (kitclass = 21) BEGIN
	  PATCH_IF (FILE_EXISTS_IN_GAME ~%kitclab%.2da~) BEGIN
		INNER_ACTION BEGIN
		  APPEND ~%kitclab%.2da~ ~SPL_REST     GA_D5SPM3M  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** 
SHAMAN_LRN   GA_D5SHMV1  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
		END
	  END
	END
//	SPRINT $d5_shaman_clabs ("%modclab%") "%modclass%" END
  END
BUT_ONLY

COPY ~faiths_and_powers/kits/incarnates/splshmkn.2da~ ~override~

// ***** need to handle +slot items

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


//REMOVE BLANK LINES MACRO_____________________________________________________________
//
DEFINE_PATCH_MACRO ~remove_blank_lines~ BEGIN
	SET "size" = (SOURCE_SIZE - 1)
	READ_BYTE ("%size%") "eof"
	WHILE ((%size% > 0) AND (("%eof%" = 0x0a) OR ("%eof%" = 0x0d))) BEGIN // removes any empty lines at the end of the file
		DELETE_BYTES "%size%" 0x01
		SET "size" = ("%size%" - 1)
		READ_BYTE ("%size%") "eof"
	END
END


//__________________________________________________________________________________
//__________________________________________________________________________________


// converts spell to innate and lowers casting time by two

DEFINE_PATCH_MACRO ~spell_to_innate~ BEGIN

  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0
  READ_ASCII (abil_off + 0x04) bam (8) // reads the bam filename from ability
  WRITE_SHORT 0x1C 4                         // sets spell type to innate (4)
  WRITE_LONG  0x34 1                         // sets spell level to 1 to avoid scripting issues
  WRITE_ASCIIE 0x3A "%bam%" #8      // writes the bam filename from abilities to spell icon
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) 4 // changes ability icon location to innate (4)
    READ_SHORT  (abil_off + 0x12 + (0x28 * index)) speed // reads casting speed
    PATCH_IF (speed > 3) BEGIN
      WRITE_SHORT  (abil_off + 0x12 + (0x28 * index)) (speed - 2) // reduces casting speed
    END ELSE BEGIN
      WRITE_SHORT  (abil_off + 0x12 + (0x28 * index)) 0 // makes instant
    END
  END

END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_PATCH_FUNCTION make_summon
  INT_VAR power_level = "-1"
BEGIN
  WRITE_LONG 0x0010 THIS | BIT1      // No corpse
  WRITE_LONG 0x0014 0                // XP
  WRITE_LONG 0x001c 0                // Gold
  WRITE_BYTE 0x0270 IDS_OF_SYMBOL("ea" "neutral")

  // Play nice with Remove Summoning Cap from D0Tweak
  PATCH_IF FILE_EXISTS "override/no_summoning_cap.d0"
  BEGIN
    WRITE_BYTE  0x0275 20       // D0Tweak alt. value
  END
  ELSE
  BEGIN
    WRITE_BYTE  0x0275 IDS_OF_SYMBOL("gender" "summoned")
  END

  // Add unstealable&undroppable flags to carried items
  GET_OFFSET_ARRAY itm_array CRE_V10_ITEMS
  PHP_EACH itm_array AS int => itm_offset
  BEGIN
    WRITE_LONG (itm_offset + 0x0010) (THIS | (BIT1 | BIT3))
  END

  // Handle power level if specified
  PATCH_IF (power_level >= 0)
  BEGIN
    WRITE_LONG  0x0018 power_level
  END
END 


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION fix_kitlist_missing_ids BEGIN
  COPY_EXISTING ~kitlist.2da~ ~override~
    PRETTY_PRINT_2DA
    PATCH_IF ~%entry%~ STR_EQ ~~ BEGIN
      READ_2DA_ENTRY 1 0 1 "entry"
    END
    COUNT_2DA_COLS "cols"
    SET cnt = 0
    REPLACE_EVALUATE ~^\(.+\)$~ BEGIN
      PATCH_IF cnt >= 3 BEGIN
        INNER_PATCH_SAVE MATCH1 ~%MATCH1%~ BEGIN
          COUNT_REGEXP_INSTANCES ~ +~ num_matches
          WHILE (num_matches < (cols - 1)) BEGIN
            REPLACE_TEXTUALLY ~$~ ~  ZZZZZ~
            SET num_matches = num_matches + 1
          END
        END
      END ELSE BEGIN
      	SET cnt = cnt + 1
      END
    END ~%MATCH1%~
    PRETTY_PRINT_2DA
  BUT_ONLY

  COPY_EXISTING ~kitlist.2da~ ~override~
    COUNT_2DA_ROWS 10 k_rows
    FOR (k_row = 1; k_row < k_rows; ++k_row) BEGIN
      SPRINT ids_num ~0x00004000~
      READ_2DA_ENTRY k_row 9 10 ids_val
      PATCH_IF !(IS_AN_INT %ids_val%) /*(~%ids_val%~ STRING_EQUAL_CASE ~ZZZZZ~)*/ BEGIN
        READ_2DA_ENTRY k_row 1 10 kit_name
        INNER_ACTION BEGIN
          COPY_EXISTING ~kit.ids~ ~override~
            COUNT_2DA_ROWS 2 i_rows
            FOR (i_row = 1; i_row < i_rows; ++i_row) BEGIN
              READ_2DA_ENTRY i_row 1 2 ids_name
              PATCH_IF (~%ids_name%~ STRING_EQUAL_CASE ~%kit_name%~) BEGIN
                READ_2DA_ENTRY i_row 0 2 ids_num
              END
            END
          IF_EXISTS BUT_ONLY
        END
        SPRINTF ids_hex "%x" (%ids_num%)
        SPRINT new_ids_val ~zzzzz%ids_hex%~
        SET_2DA_ENTRY k_row 9 10 ~%new_ids_val%~
      END
    END
  BUT_ONLY
  
  COPY_EXISTING ~kitlist.2da~ ~override~
    REPLACE_TEXTUALLY ~zzzzz0x4~ ~0x00004~
  BUT_ONLY
END


//__________________________________________________________________________________
//__________________________________________________________________________________


/* do this in the code...??
OUTER_INNER_PATCH ~1~ BEGIN
  WRITE_BYTE 0 0x09
  READ_ASCII 0 tab (1)  // 0x09, tab
  WRITE_BYTE 0 0x0d
  READ_ASCII 0 mnl (1)  // 0x0d, Mac
END
*/

DEFINE_PATCH_FUNCTION ~TRA2STR~ // given tra reference, returns string
  STR_VAR tra = ~~ // e.g. ~@123~
  RET str
BEGIN
  PATCH_IF ((~%tra%~ STRING_MATCHES_REGEXP ~@-?[0-9]+~) == 0) BEGIN
    INNER_ACTION BEGIN
      <<<<<<<< .../inlined/mi_tra2str.tph
        OUTER_SPRINT str %tra%
      >>>>>>>>
      COPY - ~.../inlined/mi_tra2str.tph~ ~.../inlined/mi_tra2str.tph~
        EVALUATE_BUFFER
      REINCLUDE ~.../inlined/mi_tra2str.tph~
    END
  END
  ELSE BEGIN
    TEXT_SPRINT str ~%tra%~
  END
END

DEFINE_ACTION_FUNCTION ~ADD_ITEM_TOOLTIPS~
  STR_VAR item = ~~     // e.g. ~sw1h01~
          tooltips = ~~ // e.g. ~@123 @124 6620~, takes combination of tra refs and strrefs for as many abilities as you need to specify
BEGIN
  ACTION_IF (STRING_LENGTH ~%item%~ > 0) BEGIN
    // generate our row to add to tooltip.2da
    OUTER_TEXT_SPRINT row ~%item%~
    OUTER_PATCH ~ %tooltips%~ BEGIN // extract our tooltips from the tooltips string
      REPLACE_EVALUATE ~[ %tab%]+\(@?-?[0-9]+\)~ BEGIN
        PATCH_IF ((~%MATCH1%~ STRING_MATCHES_REGEXP ~@-?[0-9]+~) == 0) BEGIN // tra ref
          // look up string for given tra reference
          LAUNCH_PATCH_FUNCTION ~TRA2STR~ STR_VAR tra = EVALUATE_BUFFER ~%MATCH1%~ RET str = str END
          // use REPLACE to get a strref for our new string
          INNER_PATCH ~0~ BEGIN
            REPLACE ~0~ ~%str%~
            READ_2DA_ENTRY 0 0 1 strref
          END
          TEXT_SPRINT row ~%row% %strref%~ // add to our row
        END
        ELSE BEGIN // strref
          TEXT_SPRINT row ~%row% %MATCH1%~ // add to our row
        END
      END ~~
    END
    
    COPY_EXISTING ~tooltip.2da~ ~override~
      REPLACE_TEXTUALLY ~^[ %tab%]*%item%[ %tab%].*~ ~~ // remove previous row for this item if it exists
      COUNT_2DA_ROWS 1 num_rows
      INSERT_2DA_ROW num_rows 1 ~%row%~ // insert our row at the end
      
      // ensure all rows have -1 entries in unused columns
      REPLACE_TEXTUALLY ~^[ %tab%]*0?[ %tab%]*1[ %tab%]+2[ %tab%]+3.*~ ~~ // remove column labels for now
      COUNT_2DA_COLS num_cols
      TEXT_SPRINT entries ~~
      TEXT_SPRINT col_labels ~~
      FOR (i = 1; i < (num_cols - 1); i += 1) BEGIN // for each number of columns less than there should be
        TEXT_SPRINT entries ~%entries%[ %tab%]+[0-9-]+~ // generate regexp to detect this many columns
        TEXT_SPRINT empties ~~
        FOR (j = (num_cols - 1); j > i; j -= 1) BEGIN // generate -1 entries for the number of missing columns
          TEXT_SPRINT empties ~%empties% -1~
        END
        REPLACE_TEXTUALLY ~^\([ %tab%]*[^ %tab%]+%entries%\)[ %tab%]*[%mnl%]?$~ ~\1%empties%~ // add -1 entries to all rows with this many missing columns
        TEXT_SPRINT col_labels ~%col_labels% %i%~ // generate fresh column labels
      END
      INSERT_2DA_ROW 2 1 ~%col_labels% %i%~ // re-add column labels, with last entry where i == (num_cols - 1)
      PRETTY_PRINT_2DA
      REPLACE_TEXTUALLY ~2DA +~ ~2DA ~
    
  END
END


//__________________________________________________________________________________
//__________________________________________________________________________________


//GENERATE NEW SPECIFICS MACRO______________________________________________________
//
DEFINE_ACTION_FUNCTION d5_resolve_specific STR_VAR new_specific_id = ~blah~ RET new_specific_ind BEGIN
  OUTER_SET spec_ind = IDS_OF_SYMBOL (~splstate~ ~%new_specific_id%~)
  ACTION_IF !(spec_ind = 0 - 1) BEGIN
    OUTER_SET new_specific_ind = spec_ind
  END
  ACTION_IF (spec_ind = 0 - 1) BEGIN
    OUTER_SET new_specific_ind = 0
    COPY_EXISTING ~specific.ids~ ~override~
      READ_2DA_ENTRIES_NOW rows 2
      PATCH_IF (rows < 256) BEGIN
        SET found = 0
        FOR (row = 1; row < rows; ++row) BEGIN
          PATCH_IF (found = 0) BEGIN
            READ_2DA_ENTRY_FORMER rows row 0 ind
            READ_2DA_ENTRY_FORMER rows row 1 spec
            SET poss_ind = (ind + 1)
            PATCH_IF (poss_ind < 256) BEGIN
              LOOKUP_IDS_SYMBOL_OF_INT poss_spec ~specific~ poss_ind
              PATCH_IF (~%poss_spec%~ STRING_EQUAL_CASE ~%poss_ind%~) BEGIN
                SET found = 1
                SET new_specific_ind = poss_ind
              END
            END
          END
        END
      END
    BUT_ONLY
    ACTION_IF (new_specific_ind > 0) BEGIN
      APPEND ~specific.ids~ ~%new_specific_ind%  %new_specific_id%~
    END
  END 
END


//__________________________________________________________________________________
//__________________________________________________________________________________


//ADD SPELLSTATE MACRO______________________________________________________________
//
DEFINE_ACTION_FUNCTION d5_resolve_state STR_VAR new_state_id = ~blah~ RET new_state_ind BEGIN
  OUTER_SET state_ind = IDS_OF_SYMBOL (~splstate~ ~%new_state_id%~)
  ACTION_IF !(state_ind = 0 - 1) BEGIN
    OUTER_SET new_state_ind = state_ind
  END
  ACTION_IF (state_ind = 0 - 1) BEGIN
    OUTER_SET new_state_ind = 0
    COPY_EXISTING ~splstate.ids~ ~override~
      READ_2DA_ENTRIES_NOW rows 2
      PATCH_IF (rows < 256) BEGIN
        SET found = 0
        FOR (row = 1; row < rows; ++row) BEGIN
          PATCH_IF (found = 0) BEGIN
            READ_2DA_ENTRY_FORMER rows row 0 ind
            READ_2DA_ENTRY_FORMER rows row 1 state
            SET poss_ind = (ind + 1)
            PATCH_IF (poss_ind < 256) BEGIN
              LOOKUP_IDS_SYMBOL_OF_INT poss_state ~splstate~ poss_ind
              PATCH_IF (~%poss_state%~ STRING_EQUAL_CASE ~%poss_ind%~) BEGIN
                SET found = 1
                SET new_state_ind = poss_ind
              END
            END
          END
        END
      END
    BUT_ONLY
    ACTION_IF (new_state_ind > 0) BEGIN
      APPEND ~splstate.ids~ ~%new_state_ind%  %new_state_id%~
    END
  END
END 


//__________________________________________________________________________________
//__________________________________________________________________________________


//HLA FUNCTIONS_____________________________________________________________________
//
DEFINE_PATCH_FUNCTION patch_add_hla
  STR_VAR
	2da_row = ~1~
    ability = ~*~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
BEGIN
  COUNT_2DA_COLS cols // amount of columns
  COUNT_2DA_ROWS cols rows // amount of rows
  READ_2DA_ENTRIES_NOW file cols // read all file into memory  
  SET first_empty_row = rows // default value to amount of rows in order to skip removal if the table is full
  FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
    SET empty_col_count = 0 // amount of empty columns in the row
    FOR (j = 0; j < cols; ++j) BEGIN // iterate over columns in the row
      READ_2DA_ENTRY_FORMER file i j col_value // read column value
      PATCH_IF (~%col_value%~ STRING_EQUAL ~*~) BEGIN // asterisk symbolizes empty column
        SET empty_col_count += 1
      END
    END
    PATCH_IF (%empty_col_count% = (cols - 1)) BEGIN // first column in every row is its number, that's why (cols - 1)
      SET first_empty_row = i // remember the first empty row
      SET i = file // skip iterating over the rest of the rows
    END
  END
  PATCH_IF  (cols = 9) BEGIN
    INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
  END
  PATCH_IF  (cols = 10) BEGIN
    INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
  END
  PRETTY_PRINT_2DA
END

DEFINE_PATCH_FUNCTION patch_remove_hla
  STR_VAR
    remove_ability = ~*~
BEGIN
  COUNT_2DA_COLS cols // amount of columns
  COUNT_2DA_ROWS cols rows // amount of rows
  READ_2DA_ENTRIES_NOW file cols // read all file into memory
  SET num_deleted = 0
  FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
    READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
    PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
      REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
      SET num_deleted += 1
    END
  END
END

DEFINE_PATCH_FUNCTION patch_replace_hla
  STR_VAR
    remove_ability = ~*~
	2da_row = ~1~
    ability = ~*~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
BEGIN
  COUNT_2DA_COLS cols // amount of columns
  COUNT_2DA_ROWS cols rows // amount of rows
  READ_2DA_ENTRIES_NOW file cols // read all file into memory
  SET num_deleted = 0
  FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
    READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
    PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
      REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
      SET num_deleted += 1
    END
  END
  PATCH_IF !(num_deleted = 0) BEGIN
    FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
      SET empty_col_count = 0 // amount of empty columns in the row
      FOR (j = 0; j < cols; ++j) BEGIN // iterate over columns in the row
        READ_2DA_ENTRY_FORMER file i j col_value // read column value
        PATCH_IF (~%col_value%~ STRING_EQUAL ~*~) BEGIN // asterisk symbolizes empty column
          SET empty_col_count += 1
        END
      END
      PATCH_IF (%empty_col_count% = (cols - 1)) BEGIN // first column in every row is its number, that's why (cols - 1)
        SET first_empty_row = i // remember the first empty row
        SET i = file // skip iterating over the rest of the rows
      END
    END
    PATCH_IF  (cols = 9) BEGIN
      INSERT_2DA_ROW (~%first_empty_row%~ - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
    END
    PATCH_IF  (cols = 10) BEGIN
      INSERT_2DA_ROW (~%first_empty_row%~ - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
    END
  END
  PRETTY_PRINT_2DA
END

DEFINE_ACTION_FUNCTION get_hla_table
  STR_VAR
    kit_name = ~~
  RET
    hla_table
BEGIN
  COPY_EXISTING ~luabbr.2da~ ~override~
    READ_2DA_ENTRIES_NOW file 2 // read all file into memory
    FOR (row = 1; row < file; row += 1) BEGIN // iterate over rows
      READ_2DA_ENTRY_FORMER ~file~ row 0 kit
      READ_2DA_ENTRY_FORMER ~file~ row 1 table
      TEXT_SPRINT $d5_hla_tables(~%kit%~) ~%table%~
    END
  BUT_ONLY
  ACTION_PHP_EACH d5_hla_tables AS ind => tab BEGIN
    ACTION_IF (~%ind%~ STRING_EQUAL_CASE ~%kit_name%~) BEGIN
      OUTER_TEXT_SPRINT hla_table ~%tab%~
    END
  END
END

DEFINE_ACTION_FUNCTION action_add_hla
  STR_VAR
    kit_name = ~~
	2da_row = ~1~
    ability = ~*~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~luabbr.2da~ ~override~
	COUNT_2DA_COLS l_cols // amount of columns
	READ_2DA_ENTRIES_NOW l_rows l_cols // read all file into memory  
	FOR (l_row = 1; l_row < l_rows; ++l_row) BEGIN // iterate over rows
	  READ_2DA_ENTRY_FORMER l_rows l_row 0 ~l_kit~ // read column value
	  PATCH_IF (~%l_kit%~ STRING_EQUAL_CASE ~%kit_name%~) BEGIN
	    SET lu_row = %l_row%
	    READ_2DA_ENTRY_FORMER l_rows lu_row 1 ~l_table~ // read column value
	  END
	END
  BUT_ONLY
  ACTION_IF (FILE_EXISTS_IN_GAME ~lu%l_table%.2da~) BEGIN
    COPY_EXISTING ~lu%l_table%.2da~ ~override/lud5_%lu_row%.2da~ 
	    COUNT_2DA_COLS cols // amount of columns
	    COUNT_2DA_ROWS cols rows // amount of rows
	    READ_2DA_ENTRIES_NOW file cols // read all file into memory  
	    SET first_empty_row = rows // default value to amount of rows in order to skip removal if the table is full
	    FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
	      SET empty_col_count = 0 // amount of empty columns in the row
	      FOR (j = 0; j < cols; ++j) BEGIN // iterate over columns in the row
	        READ_2DA_ENTRY_FORMER file i j col_value // read column value
	        PATCH_IF (~%col_value%~ STRING_EQUAL ~*~) BEGIN // asterisk symbolizes empty column
	          SET empty_col_count += 1
	        END
	      END
	      PATCH_IF (%empty_col_count% = (cols - 1)) BEGIN // first column in every row is its number, that's why (cols - 1)
	        SET first_empty_row = i // remember the first empty row
	        SET i = file // skip iterating over the rest of the rows
	      END
	    END  
	    PATCH_IF (VARIABLE_IS_SET %first_empty_row%) BEGIN
          PATCH_IF (cols = 9) BEGIN
	        INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
	      END
          PATCH_IF (cols = 10) BEGIN
	        INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
	      END
	    END 
	    ELSE BEGIN
          PATCH_IF (cols = 9) BEGIN
	        INSERT_2DA_ROW (%rows%) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
	      END
          PATCH_IF (cols = 10) BEGIN
	        INSERT_2DA_ROW (%rows%) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
	      END
	    END
	    PRETTY_PRINT_2DA
    ACTION_IF !(~%l_table%~ STRING_EQUAL_CASE ~d5_%lu_row%~) BEGIN
      COPY_EXISTING ~LUABBR.2DA~ ~override~
        SET_2DA_ENTRY %lu_row% 1 2 ~d5_%lu_row%~
    END
  END
END

DEFINE_ACTION_FUNCTION add_hla_to_table
  STR_VAR
    table_name = ~~
    2da_row = ~1~
    ability = ~*~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
BEGIN
  ACTION_IF (FILE_EXISTS_IN_GAME ~%table_name%.2da~) BEGIN
    COPY_EXISTING ~%table_name%.2da~ ~override~ 
      COUNT_2DA_COLS cols // amount of columns
      COUNT_2DA_ROWS cols rows // amount of rows
      READ_2DA_ENTRIES_NOW file cols // read all file into memory  
      SET first_empty_row = rows // default value to amount of rows in order to skip removal if the table is full
      FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
        SET empty_col_count = 0 // amount of empty columns in the row
        FOR (j = 0; j < cols; ++j) BEGIN // iterate over columns in the row
          READ_2DA_ENTRY_FORMER file i j col_value // read column value
          PATCH_IF (~%col_value%~ STRING_EQUAL ~*~) BEGIN // asterisk symbolizes empty column
            SET empty_col_count += 1
          END
        END
        PATCH_IF (%empty_col_count% = (cols - 1)) BEGIN // first column in every row is its number, that's why (cols - 1)
          SET first_empty_row = i // remember the first empty row
          SET i = file // skip iterating over the rest of the rows
        END
      END  
      PATCH_IF (VARIABLE_IS_SET %first_empty_row%) BEGIN
        PATCH_IF (cols = 9) BEGIN
          INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
        END
        PATCH_IF (cols = 10) BEGIN
          INSERT_2DA_ROW (~%first_empty_row%~) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
        END
      END 
      ELSE BEGIN
        PATCH_IF (cols = 9) BEGIN
          INSERT_2DA_ROW (%rows%) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
        END
        PATCH_IF (cols = 10) BEGIN
          INSERT_2DA_ROW (%rows%) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
        END
      END
      PRETTY_PRINT_2DA
	BUT_ONLY
  END
END

DEFINE_ACTION_FUNCTION action_remove_hla
  STR_VAR
    kit_name = ~~
    remove_ability = ~*~
BEGIN
  COPY_EXISTING ~luabbr.2da~ ~override~
	COUNT_2DA_COLS l_cols // amount of columns
	READ_2DA_ENTRIES_NOW l_rows l_cols // read all file into memory  
	FOR (l_row = 1; l_row < l_rows; ++l_row) BEGIN // iterate over rows
	  READ_2DA_ENTRY_FORMER l_rows l_row 0 ~l_kit~ // read column value
	  PATCH_IF (~%l_kit%~ STRING_EQUAL_CASE ~%kit_name%~) BEGIN
	    SET lu_row = %l_row%
	    READ_2DA_ENTRY_FORMER l_rows lu_row 1 ~l_table~ // read column value
	  END
	END
  BUT_ONLY
  ACTION_IF (FILE_EXISTS_IN_GAME ~lu%l_table%.2da~) BEGIN
    COPY_EXISTING ~lu%l_table%.2da~ ~override/lud5_%lu_row%.2da~ 
	  COUNT_2DA_COLS cols // amount of columns
	  COUNT_2DA_ROWS cols rows // amount of rows
	  READ_2DA_ENTRIES_NOW file cols // read all file into memory
	  SET num_deleted = 0
	  FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
	    READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
	    PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
	      REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
	      SET num_deleted += 1
	    END
	  END
    ACTION_IF !(~%l_table%~ STRING_EQUAL_CASE ~d5_%lu_row%~) BEGIN
      COPY_EXISTING ~LUABBR.2DA~ ~override~
        SET_2DA_ENTRY %lu_row% 1 2 ~d5_%lu_row%~
    END
  END
END

DEFINE_ACTION_FUNCTION action_replace_hla
  STR_VAR
    kit_name = ~~
    remove_ability = ~*~
	2da_row = ~1~
    ability = ~*~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~luabbr.2da~ ~override~
	COUNT_2DA_COLS l_cols // amount of columns
	READ_2DA_ENTRIES_NOW l_rows l_cols // read all file into memory  
	FOR (l_row = 1; l_row < l_rows; ++l_row) BEGIN // iterate over rows
	  READ_2DA_ENTRY_FORMER l_rows l_row 0 ~l_kit~ // read column value
	  PATCH_IF (~%l_kit%~ STRING_EQUAL_CASE ~%kit_name%~) BEGIN
	    SET lu_row = %l_row%
	    READ_2DA_ENTRY_FORMER l_rows lu_row 1 ~l_table~ // read column value
	  END
	END
  BUT_ONLY
  ACTION_IF (FILE_EXISTS_IN_GAME ~lu%l_table%.2da~) BEGIN
    COPY_EXISTING ~lu%l_table%.2da~ ~override/lud5_%lu_row%.2da~ 
	  COUNT_2DA_COLS cols // amount of columns
	  COUNT_2DA_ROWS cols rows // amount of rows
	  READ_2DA_ENTRIES_NOW file cols // read all file into memory
	  SET num_deleted = 0
	  FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
	    READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
	    PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
	      READ_2DA_ENTRY_FORMER file i 2 old_icon
	      READ_2DA_ENTRY_FORMER file i 3 old_strref
	      READ_2DA_ENTRY_FORMER file i 4 old_min_lev
	      READ_2DA_ENTRY_FORMER file i 5 old_max_level
	      READ_2DA_ENTRY_FORMER file i 6 old_num_allowed
	      READ_2DA_ENTRY_FORMER file i 7 old_prerequisite
	      READ_2DA_ENTRY_FORMER file i 8 old_excluded_by
	      READ_2DA_ENTRY_FORMER file i 9 old_alignment_restrict
	      PATCH_IF (~%icon%~ STRING_EQUAL_CASE ~*~) AND !(~%old_icon%~ STRING_EQUAL_CASE ~*~) BEGIN
	        SPRINT icon ~%old_icon%~
	      END
	      PATCH_IF (~%strref%~ STRING_EQUAL_CASE ~*~) AND !(~%old_strref%~ STRING_EQUAL_CASE ~*~) BEGIN
	        SPRINT strref ~%old_strref%~
	      END
	      PATCH_IF (~%min_lev%~ STRING_EQUAL_CASE ~1~) AND !(~%old_min_lev%~ STRING_EQUAL_CASE ~1~) BEGIN
	        SPRINT min_lev ~%old_min_lev%~
	      END
	      PATCH_IF (~%max_level%~ STRING_EQUAL_CASE ~99~) AND !(~%old_max_level%~ STRING_EQUAL_CASE ~99~) BEGIN
	        SPRINT max_level ~%old_max_level%~
	      END
	      PATCH_IF (~%num_allowed%~ STRING_EQUAL_CASE ~1~) AND !(~%old_num_allowed%~ STRING_EQUAL_CASE ~1~) BEGIN
	        SPRINT num_allowed ~%old_num_allowed%~
	      END
	      PATCH_IF (~%prerequisite%~ STRING_EQUAL_CASE ~*~) AND !(~%old_prerequisite%~ STRING_EQUAL_CASE ~*~) BEGIN
	        SPRINT prerequisite ~%old_prerequisite%~
	      END
	      PATCH_IF (~%excluded_by%~ STRING_EQUAL_CASE ~*~) AND !(~%old_excluded_by%~ STRING_EQUAL_CASE ~*~) BEGIN
	        SPRINT excluded_by ~%old_excluded_by%~
	      END
	      PATCH_IF (~%alignment_restrict%~ STRING_EQUAL_CASE ~*~) AND !(~%old_alignment_restrict%~ STRING_EQUAL_CASE ~*~) BEGIN
	        SPRINT alignment_restrict ~%old_alignment_restrict%~
	      END
	      REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
	      SET num_deleted += 1
	    END
	  END
	  PATCH_IF (num_deleted > 0) BEGIN
	    FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
	      SET empty_col_count = 0 // amount of empty columns in the row
	      FOR (j = 0; j < cols; ++j) BEGIN // iterate over columns in the row
	        READ_2DA_ENTRY_FORMER file i j col_value // read column value
	        PATCH_IF (~%col_value%~ STRING_EQUAL ~*~) BEGIN // asterisk symbolizes empty column
	          SET empty_col_count += 1
	        END
	      END
	      PATCH_IF (%empty_col_count% = (cols - 1)) BEGIN // first column in every row is its number, that's why (cols - 1)
	        SET first_empty_row = i // remember the first empty row
	        SET i = file // skip iterating over the rest of the rows
	      END
	    END  
	    PATCH_IF (VARIABLE_IS_SET %first_empty_row%) BEGIN
          PATCH_IF (cols = 9) BEGIN
	        INSERT_2DA_ROW (~%first_empty_row%~ - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
	      END
          PATCH_IF (cols = 10) BEGIN
	        INSERT_2DA_ROW (~%first_empty_row%~ - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
	      END
	    END 
	    ELSE BEGIN
          PATCH_IF (cols = 9) BEGIN
	        INSERT_2DA_ROW (rows - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by%~
	      END
          PATCH_IF (cols = 10) BEGIN
	        INSERT_2DA_ROW (rows - 1) %cols% ~%2da_row% %ability% %icon% %strref% %min_lev% %max_level% %num_allowed% %prerequisite% %excluded_by% %alignment_restrict%~
	      END
	    END
	  END
	  PRETTY_PRINT_2DA
    ACTION_IF !(~%l_table%~ STRING_EQUAL_CASE ~d5_%lu_row%~) BEGIN
      COPY_EXISTING ~LUABBR.2DA~ ~override~
        SET_2DA_ENTRY %lu_row% 1 2 ~d5_%lu_row%~
    END
  END
END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION add_extra_kit INT_VAR num_extra = 1 BEGIN

ACTION_IF !(FILE_EXISTS ~override/d5_extra.2da~) BEGIN
  COPY_EXISTING ~clabfi01.2da~ ~override/d5_extra.2da~
END

ADD_KIT ~D5_EXTRA%num_extra%~
//___________________________________________________________________________________

//WEAPON PROFICIENCIES_______________________________________________________________
//11          			                         T   S           F   Q             S S
//10          			 L S                     W   C           L   U             W I
//9           			 A M             B L S   O   I   W       A   A             O N
//8           			 R A             A O H   H   M   A       I   R C   S       R G
//7           			 G L           M S N O   A   I   R     H L   T R L H     2 D L 2                 E E E E E E E E E E E
//6           			 E L       S   I T G R   N K T D H     A M   E O O O     H A E W E E E E E E E E X X X X X X X X X X X
//5           			 S S   S B P   S A S T   D A A A A   S L O   R S N R   S A N W E X X X X X X X X T T T T T T T T T T T
//4           			 W W   P L I   S R W S   E T R G M C P B R M S S G T D L N D E A T T T T T T T T R R R R R R R R R R R
//3           			 O O B E U K A I D O W A D A W G M L E E N A T B B B A I D S A P R R R R R R R R A A A A A A A A A A A
//2           			 R R O A N E X L S R O X S N A E E U A R I C A O O O R N E H P O A A A A A A A A 1 1 1 1 1 1 1 1 1 1 2
//1           			 D D W R T D E E W D R E W A K R R B R D N E F W W W T G D I O N 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
~D5_EXTRA%num_extra%     0 0 0 0 0 0 0 0~
~D5_EXTRA%num_extra%     0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0~

//MINIMUM KIT STATS_________________________________________________________________
//                			 STR DEX CON INT WIS CHR
~D5_EXTRA%num_extra%          0   0   0   0   0   0~

//KIT STAT MODIFIERS________________________________________________________________
//                			 STR DEX CON INT WIS CHR
~D5_EXTRA%num_extra%          0   0   0   0   0   0~

//REQUIREMENTS TO DUAL TO THIS KIT__________________________________________________
//                			 STR DEX CON INT WIS CHR
~D5_EXTRA%num_extra%          17  17  17  17  17  17~

//REQUIREMENTS TO DUAL FROM THIS KIT________________________________________________
//                			 STR DEX CON INT WIS CHR
~D5_EXTRA%num_extra%          15  15  15  15  15  15~

//ALIGNMENT RESTRICTIONS____________________________________________________________
//                			 LG LN LE NG TN NE CG CN CE
~D5_EXTRA%num_extra%          0  0  0  0  1  0  0  0  0~

//DUAL CLASS OPTIONS________________________________________________________________
//                			 FT CL MA TH DR RA
~D5_EXTRA%num_extra%          0  0  0  0  0  0~

//KIT ABILITIES 2DA FILE_____________________________________________________________
~override/d5_extra.2da~

//RACIAL KIT AVAILABILITY____________________________________________________________
~~

//UNUSABLE FLAGS AND KIT BASE CLASS__________________________________________________
//CLASSES: Mage = 1, Fighter = 2, Cleric=3, Thief = 4, Bard = 5
//         Paladin 6, Druid = 11, Ranger = 12, Sorcerer = 19
//         Monk = 20
~0x00004000 20~

//HIGH LEVEL ABILITIES ABBREVIATION__________________________________________________
~Fi0~

//TOB STARTING EQUIPMENT_____________________________________________________________
~LEAT14	* HELM07 BAG20 RING06 RING31 CLCK02 BOOT01 AMUL19 BRAC16 BELT06 AROW11,40 BULL03,40 BOLT06,40 POTN52,5 POTN04,2 POTN14,5 HAMM07 SW1H39 STAF08~

//CHARACTER CREATION KIT DESCRIPTION________________________________________________
SAY ~D5_EXTRA%num_extra%~
SAY ~D5_EXTRA%num_extra%~
SAY ~Extra kit %num_extra%~
//___________________________________________________________________________________

//EE KIT EXTRAS______________________________________________________________________
//
ACTION_IF GAME_IS ~bgee bg2ee iwdee~ THEN BEGIN
	LAF fl#add_kit_ee
		INT_VAR
			briefdesc = RESOLVE_STR_REF (~D5_EXTRA%num_extra%~)
		STR_VAR
			kit_name = EVAL ~D5_EXTRA%num_extra%~
			clswpbon = ~0 0 2~
	END
END
//____________________________________________________________________________________

END	//	end define function


//___________________________________________________________________________________
//___________________________________________________________________________________


DEFINE_ACTION_FUNCTION check_kit_conflict BEGIN

COPY_EXISTING ~kit.ids~ ~override~
  COUNT_2DA_ROWS 2 rows
  READ_2DA_ENTRY (rows - 1) 0 2 last_kit
  PATCH_IF (~%last_kit%~ STRING_EQUAL_CASE ~0x403f~) BEGIN
	INNER_ACTION BEGIN
	  LAF add_extra_kit INT_VAR num_extra = 4040 END
	END
  END
  PATCH_IF (~%last_kit%~ STRING_EQUAL_CASE ~0x407f~) BEGIN
	INNER_ACTION BEGIN
	  LAF add_extra_kit INT_VAR num_extra = 4080 END
	END
  END
  PATCH_IF (~%last_kit%~ STRING_EQUAL_CASE ~0x40FF~) BEGIN
	INNER_ACTION BEGIN
	  LAF add_extra_kit INT_VAR num_extra = 4100 END
	END
  END
BUT_ONLY

END	//	end define function


//___________________________________________________________________________________
//___________________________________________________________________________________


// These are edited versions of Cam's DELETE/CLONE/ALTER_EFFECT (shipped with WEIDU)
// that allows for finer control on the savingthrow and special fields, and also to 
// check the value of a function and apply one.
//
// Changes consist of (i) new INT_VAR variables; (ii) two functions and one macro, at
// end; (iii) calls to those functions and macro inserted into the code; (iv) a
// small insert into the big AND loop that checks if a match is found; (v) allowing parameter1
// and parameter2 to take negative values up to -10
//
// 4/21/19: we now include the ADD_SPELL_EFFECT and ADD_ITEM_EFFECT functions from g_functions (as functions only)
//
// 6/1/19: we now include the new MATCH_EFFECT function. It returns 'value', which is set to 1 if at least one
// effect matches the condition and to 0 otherwise.


DEFINE_PATCH_FUNCTION ADD_SPELL_EFFECT
  INT_VAR opcode = 0
          target = 0
          timing = 0
          parameter1 = 0
          parameter2 = 0
          power = 0
          resist_dispel = 0
          duration = 0
          probability1 = 100
          probability2 = 0
          dicenumber = 0
          dicesize = 0
          savingthrow = 0
          savebonus = 0
          header = 0
          insert_point = "-1"
          special = 0

    // DavidW's additional variables for the new effect
  
          parameter2a         = "-1"
          parameter2b         = "-1"
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"

  STR_VAR resource = ~~

BEGIN
  LPM dw_internal_initialise_bit
  PATCH_IF (BUFFER_LENGTH > 0x71) THEN BEGIN
    READ_LONG  0x64 ___#abil_off
    READ_SHORT 0x68 ___#abil_num
    READ_LONG  0x6a ___#fx_off

    FOR (___#index1 = 0 ; ___#index1 < ___#abil_num ; ___#index1 = ___#index1 + 1) BEGIN

      PATCH_IF (___#index1 = (header - 1)) OR (header = 0) BEGIN //header=1 means ___#index1=0
        READ_SHORT  (___#abil_off + 0x1e + (0x28 * ___#index1)) ___#abil_fx_num
        READ_SHORT  (___#abil_off + 0x20 + (0x28 * ___#index1)) ___#abil_fx_idx

        ___#insert_point = !VARIABLE_IS_SET insert_point OR !IS_AN_INT insert_point OR insert_point < 0 OR insert_point > ___#abil_fx_num ? ___#abil_fx_num : insert_point

        INSERT_BYTES (___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx))) 0x30

        WRITE_SHORT  (___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx))) opcode
        WRITE_BYTE   (___#fx_off + 0x02 + (0x30 * (___#insert_point + ___#abil_fx_idx))) target
        WRITE_BYTE   (___#fx_off + 0x03 + (0x30 * (___#insert_point + ___#abil_fx_idx))) power
        WRITE_LONG   (___#fx_off + 0x04 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter1
        WRITE_LONG   (___#fx_off + 0x08 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2
        WRITE_BYTE   (___#fx_off + 0x0c + (0x30 * (___#insert_point + ___#abil_fx_idx))) timing
        WRITE_BYTE   (___#fx_off + 0x0d + (0x30 * (___#insert_point + ___#abil_fx_idx))) resist_dispel
        WRITE_LONG   (___#fx_off + 0x0e + (0x30 * (___#insert_point + ___#abil_fx_idx))) duration
        WRITE_BYTE   (___#fx_off + 0x12 + (0x30 * (___#insert_point + ___#abil_fx_idx))) probability1
        WRITE_BYTE   (___#fx_off + 0x13 + (0x30 * (___#insert_point + ___#abil_fx_idx))) probability2
        WRITE_EVALUATED_ASCII (___#fx_off + 0x14 + (0x30 * (___#insert_point + ___#abil_fx_idx))) ~%resource%~ #8
        WRITE_LONG   (___#fx_off + 0x1c + (0x30 * (___#insert_point + ___#abil_fx_idx))) dicenumber
        WRITE_LONG   (___#fx_off + 0x20 + (0x30 * (___#insert_point + ___#abil_fx_idx))) dicesize
        WRITE_LONG   (___#fx_off + 0x24 + (0x30 * (___#insert_point + ___#abil_fx_idx))) savingthrow
        WRITE_LONG   (___#fx_off + 0x28 + (0x30 * (___#insert_point + ___#abil_fx_idx))) savebonus
        WRITE_LONG (___#fx_off + 0x2c + (0x30 * (___#insert_point + ___#abil_fx_idx))) special

        // DW addition
        PATCH_IF parameter2a>=0 BEGIN
            WRITE_SHORT  (___#fx_off + 0x08 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2a
        END
        PATCH_IF parameter2b>=0 BEGIN
            WRITE_SHORT  (___#fx_off + 0x0a + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2b
        END
        SET base=(___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx)))
        SET fx_type=0
        LPF dw_internal_set_bit END

        //correcting effects number
        WRITE_SHORT (___#abil_off + 0x1e + (0x28 * ___#index1)) (___#abil_fx_num + 1)

        //correcting 1st effect indexes
        FOR (___#index2 = 0 ; ___#index2 < ___#abil_num ; ___#index2 = ___#index2 + 1) BEGIN
          READ_SHORT (___#abil_off + ___#index2 * 0x28 + 0x20) ___#1effect_index
          PATCH_IF (___#1effect_index > ___#abil_fx_idx) //if abilility after current effect
                OR ((___#1effect_index = ___#abil_fx_idx)
                AND (___#abil_fx_num = 0)
                AND (___#index2 != ___#index1)) BEGIN
            WRITE_SHORT (___#abil_off + ___#index2 * 0x28 + 0x20) (___#1effect_index + 1) //increase 1 effect ___#index1 by 1
          END
        END
        //no offsets to correct
      END
    END
  END
END



DEFINE_PATCH_FUNCTION ADD_ITEM_EFFECT 
  INT_VAR opcode = 0
          target = 0
          timing = 0
          parameter1 = 0
          parameter2 = 0
          power = 0
          resist_dispel = 0
          duration = 0
          probability1 = 100
          probability2 = 0
          dicenumber = 0
          dicesize = 0
          savingthrow = 0
          savebonus = 0
          header = 0
		  type = 3
		  insert_point = "-1"
          special = 0

    // DavidW's additional variables for the new effect
  
          parameter2a         = "-1"
          parameter2b         = "-1"
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"

  STR_VAR resource = ~~

BEGIN
  LPM dw_internal_initialise_bit
  PATCH_IF (BUFFER_LENGTH > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 ___#abil_off //ability offset
    READ_SHORT  0x68 ___#abil_num //number of abilities
    READ_LONG   0x6a ___#fx_off //effects offset
    FOR (___#index1 = 0 ; ___#index1 < ___#abil_num ; ___#index1 = ___#index1 + 1) BEGIN // looks for magical ability header
      READ_BYTE  (___#abil_off +        (___#index1 * 0x38)) ___#type //ability type
      PATCH_IF ((!(VARIABLE_IS_SET type AND IS_AN_INT type) && ___#type = 3) OR (VARIABLE_IS_SET type AND IS_AN_INT type AND ((___#type = type) OR type = 99))) AND ((___#index1 = (header - 1)) OR (header = 0)) BEGIN //ability is correct or unspecified and header matches
        READ_SHORT  (___#abil_off + 0x1e + (0x38 * ___#index1)) ___#abil_fx_num
        READ_SHORT  (___#abil_off + 0x20 + (0x38 * ___#index1)) ___#abil_fx_idx

        ___#insert_point = !VARIABLE_IS_SET insert_point OR !IS_AN_INT insert_point OR insert_point < 0 OR insert_point > ___#abil_fx_num ? ___#abil_fx_num : insert_point

        INSERT_BYTES (___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx))) 0x30

        WRITE_SHORT  (___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx))) opcode
        WRITE_BYTE   (___#fx_off + 0x02 + (0x30 * (___#insert_point + ___#abil_fx_idx))) target
        WRITE_BYTE   (___#fx_off + 0x03 + (0x30 * (___#insert_point + ___#abil_fx_idx))) power
        WRITE_LONG   (___#fx_off + 0x04 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter1
        WRITE_LONG   (___#fx_off + 0x08 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2
        WRITE_BYTE   (___#fx_off + 0x0c + (0x30 * (___#insert_point + ___#abil_fx_idx))) timing
        WRITE_BYTE   (___#fx_off + 0x0d + (0x30 * (___#insert_point + ___#abil_fx_idx))) resist_dispel
        WRITE_LONG   (___#fx_off + 0x0e + (0x30 * (___#insert_point + ___#abil_fx_idx))) duration
        WRITE_BYTE   (___#fx_off + 0x12 + (0x30 * (___#insert_point + ___#abil_fx_idx))) probability1
        WRITE_BYTE   (___#fx_off + 0x13 + (0x30 * (___#insert_point + ___#abil_fx_idx))) probability2
        WRITE_EVALUATED_ASCII (___#fx_off + 0x14 + (0x30 * (___#insert_point + ___#abil_fx_idx))) ~%resource%~ #8
        WRITE_LONG   (___#fx_off + 0x1c + (0x30 * (___#insert_point + ___#abil_fx_idx))) dicenumber
        WRITE_LONG   (___#fx_off + 0x20 + (0x30 * (___#insert_point + ___#abil_fx_idx))) dicesize
        WRITE_LONG   (___#fx_off + 0x24 + (0x30 * (___#insert_point + ___#abil_fx_idx))) savingthrow
        WRITE_LONG   (___#fx_off + 0x28 + (0x30 * (___#insert_point + ___#abil_fx_idx))) savebonus
        WRITE_LONG (___#fx_off + 0x2c + (0x30 * (___#insert_point + ___#abil_fx_idx))) special

        // DW addition
        PATCH_IF parameter2a>=0 BEGIN
            WRITE_SHORT  (___#fx_off + 0x08 + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2a
        END
        PATCH_IF parameter2b>=0 BEGIN
            WRITE_SHORT  (___#fx_off + 0x0a + (0x30 * (___#insert_point + ___#abil_fx_idx))) parameter2b
        END
        SET base=(___#fx_off +        (0x30 * (___#insert_point + ___#abil_fx_idx)))
        SET fx_type=0
        LPF dw_internal_set_bit END

        //correcting effects number
        WRITE_SHORT (___#abil_off + 0x1e + (0x38 * ___#index1)) (___#abil_fx_num + 1)

        //correcting 1st effect ___#index1es
        FOR (___#index2 = 0 ; ___#index2 < ___#abil_num ; ___#index2 = ___#index2 + 1) BEGIN
          READ_SHORT (___#abil_off + ___#index2 * 0x38 + 0x20) ___#1effect_index
          PATCH_IF (___#1effect_index > ___#abil_fx_idx) //if next abilility
                OR ((___#1effect_index = ___#abil_fx_idx)
                AND (___#abil_fx_num = 0)
                AND (___#index2 != ___#index1)) BEGIN
            WRITE_SHORT (___#abil_off + ___#index2 * 0x38 + 0x20) (___#1effect_index + 1) //increase 1 effect ___#index1 by 1
          END
        END
        //no offsets to correct
      END
    END //end of cycle
  END
END





DEFINE_PATCH_FUNCTION CLONE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching

          match_parameter2a         = "-1"
          match_parameter2b         = "-1"
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-11"
          parameter2          = "-11"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"
          
  // DavidW's additional variables for the new effect

          parameter2a         = "-1"
          parameter2b         = "-1"
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"
          

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          insert              = "above"

  // DavidW's additional functional variables

          match_function      = ""
          function            = ""
BEGIN

  LPM dw_internal_initialise_bit
  PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.1" = 0) BEGIN // iwd2, are v9.1
    READ_LONG  0x78 ent_off
    READ_LONG  0x7c ent_num
  END ELSE BEGIN
    READ_LONG  0x68 ent_off
    READ_LONG  0x6c ent_num
  END

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_FAIL "ERROR: CLONE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_FAIL "ERROR: CLONE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET last = 0                              // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < (counter - last) ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_SHORT (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2a
          READ_SHORT (fx_off + 0x0a + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2b
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_parameter2a    = o_parameter2a)  OR (match_parameter2a < 0))   AND
                    ((match_parameter2b    = o_parameter2b)  OR (match_parameter2b < 0))   AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0)))
          BEGIN
            // now that we've got a match, read-and-clone it:
            READ_ASCII   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) clone (0x30 + (0xd8 * fx_type))
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "below" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2 + 1) * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "first" = 0) BEGIN
              SET base = (fx_off        + (abil_fx_idx * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + counter) * (0x30 + (0xd8 * fx_type))))
            END ELSE BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            END
            INSERT_BYTES base (0x30 + (0xd8 * fx_type))
            WRITE_ASCIIE base "%clone%"

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= "-10")    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= "-10")    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (parameter2a >= 0)   BEGIN WRITE_SHORT (base + 0x08 + (0x10 * fx_type)) parameter2a    END
            PATCH_IF (parameter2b >= 0)   BEGIN WRITE_SHORT (base + 0x0a + (0x10 * fx_type)) parameter2b    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END
            LPF dw_internal_set_bit END
            LPF dw_internal_apply_function END
            // update the tracking vars
            SET new_fx += 1
            SET counter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
              PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
                SET last += 1
              END ELSE BEGIN
                SET index2 += 1
              END
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx > 0)) BEGIN // fix offsets for cre files if fx inserted
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (new_fx = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects added to %SOURCE_FILE%"
  END ELSE PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) added"
  END

END

DEFINE_PATCH_FUNCTION DELETE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching

          match_parameter2a         = "-1"
          match_parameter2b         = "-1"
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
  
  // DavidW's additional functional variable

          match_function      = ""

BEGIN
  
  LPM dw_internal_initialise_bit
  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: DELETE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: DELETE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_SHORT (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2a
          READ_SHORT (fx_off + 0x0a + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2b
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_parameter2a    = o_parameter2a)  OR (match_parameter2a < 0))   AND
                    ((match_parameter2b    = o_parameter2b)  OR (match_parameter2b < 0))   AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // now that we've got a match, read-and-clone it:
            DELETE_BYTES   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) (0x30 + (0xd8 * fx_type))

            // update the tracking vars
            SET new_fx -= 1
            SET counter -= 1
            SET index2 -= 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx != 0)) BEGIN // fix offsets for cre files if #fx changed
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) deleted"
  END

END

DEFINE_PATCH_FUNCTION ALTER_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching

          match_parameter2a         = "-1"
          match_parameter2b         = "-1"
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-11"
          parameter2          = "-11"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"
          
  // DavidW's additional variables for the new effect

          parameter2a         = "-1"
          parameter2b         = "-1"
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          
  // DavidW's additional functional variables

          match_function      = ""
          function            = ""

BEGIN  
  LPM dw_internal_initialise_bit
  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off ELSE 0
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off ELSE 0
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off ELSE 0
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off ELSE 0
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_SHORT (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2a
          READ_SHORT (fx_off + 0x0a + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2b
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_parameter2a    = o_parameter2a)  OR (match_parameter2a < 0))   AND
                    ((match_parameter2b    = o_parameter2b)  OR (match_parameter2b < 0))   AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= "-10") BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= "-10")    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (parameter2a >= 0)   BEGIN WRITE_SHORT (base + 0x08 + (0x10 * fx_type)) parameter2a    END
            PATCH_IF (parameter2b >= 0)   BEGIN WRITE_SHORT (base + 0x0a + (0x10 * fx_type)) parameter2b    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END
            LPF dw_internal_set_bit END
            LPF dw_internal_apply_function END
            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE%"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END


DEFINE_PATCH_FUNCTION MATCH_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching

          match_parameter2a         = "-1"
          match_parameter2b         = "-1"
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
  
  // DavidW's additional functional variable

          match_function      = ""

  // The return value
  
  RET value

BEGIN

  SET value=0
  LPM dw_internal_initialise_bit
  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: MATCH_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: MATCH_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_SHORT (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2a
          READ_SHORT (fx_off + 0x0a + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2b
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_parameter2a    = o_parameter2a)  OR (match_parameter2a < 0))   AND
                    ((match_parameter2b    = o_parameter2b)  OR (match_parameter2b < 0))   AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            SET value=1

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop


END




DEFINE_PATCH_MACRO dw_internal_initialise_bit BEGIN
   //  DavidW: once and for all set the variables used by bit checks
  CLEAR_ARRAY bit_array_binary
  DEFINE_ASSOCIATIVE_ARRAY bit_array_binary BEGIN
             save_vs_spell         =>   0b11111110
             save_vs_breath        =>   0b11111101
             save_vs_poison        =>   0b11111011
             save_vs_wand          =>   0b11110111
             save_vs_polymorph     =>   0b11101111
             ignore_primary        =>   0b11111011
             ignore_secondary      =>   0b11110111
             bypass_mirror_image   =>   0b11111110
             ignore_difficulty     =>   0b11111101
             drain_hp_to_caster    =>   0b11111110
             transfer_hp_to_target =>   0b11111101
             fist_damage_only      =>   0b11111011
             drain_to_max_hp       =>   0b11110111
             suppress_feedback     =>   0b11011111
             save_for_half         =>   0b11111110
             made_save             =>   0b11111101
             does_not_wake         =>   0b11111011

  END
  CLEAR_ARRAY bit_array
  DEFINE_ASSOCIATIVE_ARRAY bit_array BEGIN
            save_vs_spell            =>   0x24
            save_vs_breath           =>   0x24
            save_vs_poison           =>   0x24
            save_vs_wand             =>   0x24
            save_vs_polymorph        =>   0x24
            ignore_primary           =>   0x25
            ignore_secondary         =>   0x25
            ignore_difficulty        =>   0x27
            bypass_mirror_image      =>   0x27
            drain_hp_to_caster       =>   0x2c   
            transfer_hp_to_target    =>   0x2c
            fist_damage_only         =>   0x2c
            drain_to_max_hp          =>   0x2c
            suppress_feedback        =>   0x2c
            save_for_half            =>   0x2d
            made_save                =>   0x2d
            does_not_wake            =>   0x2d

  END
END

DEFINE_PATCH_FUNCTION dw_internal_check_bit // not really encapsulated
    RET bit_test_passed
BEGIN
      SET bit_test_passed=1
      PHP_EACH bit_array AS bit_var=>bit_loc BEGIN
             SET bit_val=EVAL "match_%bit_var%"
             PATCH_IF (bit_val>=0 && bit_test_passed=1) BEGIN // if we've already failed, don't bother
                  SET bit_binary = $bit_array_binary("%bit_var%")
                  READ_BYTE  (fx_off + bit_loc + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_bit_value
                  PATCH_IF bit_val=0 BEGIN
                     PATCH_IF ! ( ((BNOT bit_binary) BAND o_bit_value) = 0b00000000) BEGIN
                        SET bit_test_passed=0
                     END
                  END ELSE BEGIN
                     PATCH_IF ! ( (bit_binary BOR o_bit_value) = 0b11111111) BEGIN
                        SET bit_test_passed=0
                     END
                  END
             END
      END
END

DEFINE_PATCH_FUNCTION dw_internal_set_bit // not really encapsulated
BEGIN
            PHP_EACH bit_array AS bit_var=>bit_loc BEGIN
             SET bit_val=EVAL "%bit_var%"
             PATCH_IF bit_val>=0 BEGIN
                SET bit_binary =$bit_array_binary("%bit_var%")
                READ_BYTE (base + bit_loc + (0x14 * fx_type)) bit_value
                PATCH_IF bit_val=0 BEGIN
                    SET bit_value = (bit_value BAND bit_binary )
                END ELSE BEGIN
                    SET bit_value = (bit_value BOR (BNOT bit_binary) )
                END
                WRITE_BYTE (base + bit_loc + (0x14 * fx_type)) bit_value
             END
            END
END

DEFINE_PATCH_FUNCTION dw_internal_evaluate_function // not really encapsulated
           RET function_test_passed
BEGIN
  // initialise
  SET function_test_passed=1

  // is there a function?
  PATCH_IF "%match_function%" STRING_COMPARE "" BEGIN

   // get the function and arguments
   SPRINT arguments ""
   INNER_PATCH_SAVE match_function "%match_function%" BEGIN
      REPLACE_EVALUATE "\(.*\)(\([^)]*\))$" BEGIN
         SPRINT arguments "%MATCH2%"
      END
      "%MATCH1%"
   END
   // get the data
   READ_ASCII (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) dw_data (0x30)
   // apply the function
   INNER_PATCH "%dw_data%" BEGIN
      LPF "%match_function%" STR_VAR arguments RET function_test_passed=value END
   END

  END
END

DEFINE_PATCH_FUNCTION dw_internal_apply_function // not really encapsulated
BEGIN

  // is there a function?
  PATCH_IF "%function%" STRING_COMPARE "" BEGIN

   // get the function and arguments
   SPRINT arguments ""
   INNER_PATCH_SAVE function "%function%" BEGIN
      REPLACE_EVALUATE "\(.*\)(\([^)]*\))$" BEGIN
         SPRINT arguments "%MATCH2%"
      END
      "%MATCH1%"
   END
   // get the data
   READ_ASCII (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) dw_data (0x30)
   // apply the function
   INNER_PATCH_SAVE dw_data "%dw_data%" BEGIN
      LPF "%function%" STR_VAR arguments END
   END
   // write the data
   WRITE_ASCIIE (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) "%dw_data%" (0x30)

  END
END

